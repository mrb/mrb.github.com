I"÷Q<p>#</p>

<div class="lead">This post is part of a series exploring a brain-melting epic known as <a href="http://www.info.ucl.ac.be/~pvr/book.html">Concepts, Techniques, and Models of Computer Programming</a>. Check the <a href="/">blog index</a> for more.</div>

<p>#</p>
<h3 id="what-is-declarative-programming">What Is Declarative Programming?</h3>

<p>Van Roy and Haridi have a way with definitions in <em>Concepts, Techniques, and Models of Computer Programming</em> (CTM), but interestingly, <em>declarative computation</em> and <em>declarative programming</em> get thrown around a lot in Chapter 2 before they are properly or even pithily defined. This post provides this definition and also looks closely at declarative programming as a paradigm: its benefits, its limitations, and how it impacts professional developers. We will also see how declarativeness relates to what is commonly understood as functional programming, and consider ways in which we can reach for declarativeness as a tool in our otherwise imperative code.</p>

<h4 id="a-definitional-and-observational-view">A Definitional and Observational View</h4>

<p>In Chapters 1 and 2, before the practical application and programming techniques of declarative programming are discussed, we learn the paradigm through the semantics of a simple kernel language which is defined by its ability to ‚Äúevaluate functions over partial values.‚Äù<a href="#bib1">[1]</a> Chapters 3 and 4 cover declarative programming in depth while rounding out the foundational Computer Science knowledge developed in the first few chapters. Declarative programming <em>as a paradigm</em> is defined, extended to include concurrency primitives (the subject of our next post), and then used to bridge the gap to a chapter on message passing concurrency.</p>

<p>Back to that definition - what does it mean to be declarative?</p>

<blockquote>
  <p>‚ÄúWe say the operation is declarative if, whenever called with the same arguments, it returns the same results independent of any other computation state.‚Äù</p>
</blockquote>

<p>To break that down, declarative computation can be described as having the following properties:</p>

<ul>
  <li>It is <strong><em>independent</em></strong>: it computes irrespective of other computation state</li>
  <li>It is <strong><em>stateless</em></strong>: each action is unrelated to any previous action</li>
  <li>It is <strong><em>deterministic</em></strong>: the same inputs will return the same outputs</li>
</ul>

<p>Finally, declarative programming is  described as being necessarily <em>referentially transparent</em> if ‚Äúcertain rules are followed.‚Äù <em>Referential transparency</em> is a quality ascribed to code which has mathematical origins. An expression is referentially transparent if it can be replaced with its value without changing the meaning of the program. In mathematical functions, all applications are referentially transparent: a function with a certain input will always produce a certain output, and therefore, it can be replaced by its value. This is a powerful property that allows mathematicians to reason about their ‚Äúcode‚Äù in interesting ways. If our code is declarative, it can be referentially transparent, and programmers can leverage the same benefits: ability to easily reason about structure and function, ease of composability, and more.</p>

<p>Reading these definitions of declarativeness sequentially, you may start to see the hazy picture of how the roots of functional programming are formed in the semantics of declarative programming. The authors are somewhat well known for the following diagram, which puts programming languages on a continuum from ‚Äúmore declarative‚Äù to ‚Äúless declarative‚Äù and is one of the keys to understanding the system as laid out by CTM.</p>

<center><img width="600" src="https://dl.dropboxusercontent.com/u/1401061/paradigms.jpg" />
<div class="lead">The massive paradigm chart - "More is not better (or worse) than less, just different." (<a href="http://www.info.ucl.ac.be/~pvr/paradigms.html">source</a>)</div>
</center>

<p><em>More declarative</em> programming languages, including Prolog, Haskell, Oz, and SQL, are part of a sub-group of declarative languages which have the property of using ‚ÄúUnnamed state (sequential or concurrent).‚Äù <em>More declarative</em> languages are also shown to belong to categories like ‚ÄúLazy functional programming,‚Äù ‚ÄúConstraint (logic) programming,‚Äù and ‚ÄúDeclarative concurrent programming.‚Äù</p>

<p><em>Less declarative</em> languages use ‚ÄúNamed state,‚Äù and prominent examples include Erlang, Pascal, C, and Java. Interestingly, Prolog also appears in this list (due to a Prolog programmer‚Äôs ability to forgo the maintenance of declarativeness through the use of certain operators) as does Oz, which is a multi-paradigm language. Categories of <em>less declarative</em> languages include ‚ÄúStateful functional programming,‚Äù ‚ÄúConcurrent object-oriented programming,‚Äù and ‚ÄúMessage passing concurrent programming.‚Äù</p>

<p>There is a lesser known and more narrowly scoped illustration in Chapter 3 of CTM which I have recreated here because I think it helps round out the picture of what declarative programming is and how it tends to work:</p>

<center>
<img src="https://dl.dropboxusercontent.com/u/1401061/declarative.jpg" />
<div class="lead">What is Declarative Programming? Diagram based on&lt;/br&gt;Van Roy and Haridi's, recreated with stolen imagery.</div>
</center>

<p>In other words, declarative programming is predictable, timeless, and knowable, and the rest of programming is a swirling, galactic vacuum of energy and space. Why is this? According to the paradigm diagram, declarativeness is a continuum resting on a fulcrum of statefulness. The more state we have, the more expressive we can be. Because engineering is always about tradeoffs, however, it is important to remember that state also controls how much more more imperative we become. But declarativeness is more than an intuition - it‚Äôs a knowable entity. We should be able to <em>prove</em> that declarative computation is more knowable and repeatable, and indeed we can. Here‚Äôs the process:</p>

<blockquote>
  <p>‚ÄúGiven any statement in the declarative model, partition the free variable identifiers in the statement into inputs and outputs. Then, given any binding of the input identifiers to partial values and the output variables to unbound variables, executing the statement will give one of three results: some binding of the output variables, suspension, or an exception.‚Äù</p>
</blockquote>

<p>Let‚Äôs try to apply that process to the following statement:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if X&gt;Y then Z=X else Z=Y end
</code></pre></div></div>

<p>This statement can be shown to be declarative by considering the input identifiers <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code> and the output identifier <code class="language-plaintext highlighter-rouge">Z</code>. If the input identifiers are bound to any partial values, two possibilities exist: the statement will either block or bind <code class="language-plaintext highlighter-rouge">Z</code> to a value. Since both of those possibilities are subsumed by the possibilities mentioned above, this illustrates the mechanism by which a statement can be assigned the property of declarativeness and lends concreteness to the notion that <em>independent,</em> <em>stateless,</em> <em>deterministic</em> computation is declarative.</p>

<p>In case you‚Äôre confused about why it is taken for granted that the statement will block if no binding is made, the technical reason lies in the specification of the kernel language‚Äôs <em>single assignment store</em>. <a href="http://michaelrbernste.in/2013/06/17/declarative-computation-and-the-abstract-machine.html">I covered this mechanism a little bit in this post</a>, but to make it explicit, the semantics of variables in this store are such that:</p>

<ul>
  <li>Single assignment variables can only be bound once</li>
  <li>If single assignment variables are needed in a computation before they are bound, the computation will block until an assignment is made</li>
</ul>

<p>The strict scoping rules of the declarative language also come heavily into play here in allowing units of declarative code to be composed in a way which leverages their referential transparency. Since calculating with environments in declarative code has been shown to be extremely straightforward, and it has so many benefits, the natural question arises - when is it not applicable?</p>

<h4 id="the-realm-of-the-nondeclarative">The Realm Of The Nondeclarative</h4>

<p>What kinds of problems cannot be solved declaratively? It is instructive to look above at the list of qualities which declarative code must have, because if you need any of these qualities to disappear, you know you must sacrifice at least some declarativeness. As the authors state in section <strong>4.7.4</strong> with the somewhat heavy name <strong>The Real World,</strong></p>

<blockquote>
  <p>‚ÄúThe real world is not declarative. It has both state (entities have an internal memory) and concurrency (entities evolve independently).‚Äù</p>
</blockquote>

<p>The classic examples offered include client server applications and video display applications. The inability to easily maintain state in the declarative model available at this point in the book shows that solving these problems in a purely declarative way just isn‚Äôt realistic. Instead of attempting to pull code from the middle of something more complex, I‚Äôll use an example from the book to illustrate a typical challenge posed by purely declarative code.</p>

<h4 id="example-code-instrumentation">Example: Code Instrumentation</h4>

<p>Consider a defined component in the kernel language to which a developer would like to add <em>instrumentation,</em> or a means of measuring aspects of program execution. Given a reusable component <code class="language-plaintext highlighter-rouge">SC</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">fun</span> <span class="p">{</span><span class="no">SC</span> <span class="o">...</span><span class="p">}</span>
  <span class="nb">proc</span> <span class="p">{</span><span class="no">P1</span> <span class="o">...</span><span class="p">}</span>
    <span class="o">...</span>
  <span class="k">end</span>
  <span class="nb">proc</span> <span class="p">{</span><span class="no">P2</span> <span class="o">...</span><span class="p">}</span>
    <span class="o">...</span>
    <span class="p">{</span><span class="no">P1</span> <span class="o">...</span><span class="p">}</span>
    <span class="p">{</span><span class="no">P2</span> <span class="o">...</span><span class="p">}</span>
  <span class="k">end</span>
  <span class="nb">proc</span> <span class="p">{</span><span class="no">P3</span> <span class="o">...</span><span class="p">}</span>
    <span class="o">...</span>
    <span class="p">{</span><span class="no">P2</span> <span class="o">...</span><span class="p">}</span>
    <span class="p">{</span><span class="no">P3</span> <span class="o">...</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">in</span>
 <span class="sb">`export`</span><span class="p">(</span><span class="n">p1</span><span class="ss">:P1</span> <span class="n">p2</span><span class="ss">:P2</span> <span class="n">p3</span><span class="ss">:P3</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>We can see that <code class="language-plaintext highlighter-rouge">SC</code> encapsulates three operations, <code class="language-plaintext highlighter-rouge">P1</code>, <code class="language-plaintext highlighter-rouge">P2</code>, and <code class="language-plaintext highlighter-rouge">P3</code>, and that the procedures call each other and themselves. Because this code is declarative, it can be used elsewhere in an understandable way, but in order to protect this quality, we sacrifice expressiveness. Demonstrably, in order to do something as simple as add an accumulator to this component for instrumentation purposes, we must add two arguments to each procedure: this means that we must change three procedure definitions and four procedure calls. Here‚Äôs what the altered code looks like:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">fun</span> <span class="p">{</span><span class="no">SC</span> <span class="o">...</span><span class="p">}</span>
  <span class="nb">proc</span> <span class="p">{</span><span class="no">P1</span> <span class="o">...</span> <span class="no">S1</span> <span class="p">?</span><span class="no">Sn</span><span class="p">}</span>
    <span class="no">Sn</span><span class="o">=</span><span class="no">S1</span><span class="o">+</span><span class="mi">1</span>
    <span class="o">...</span>
  <span class="k">end</span>
  <span class="nb">proc</span> <span class="p">{</span><span class="no">P2</span> <span class="o">...</span> <span class="no">T1</span> <span class="p">?</span><span class="no">Tn</span><span class="p">}</span>
    <span class="o">...</span>
    <span class="p">{</span><span class="no">P1</span> <span class="o">...</span> <span class="no">T1</span> <span class="no">T2</span><span class="p">}</span>
    <span class="p">{</span><span class="no">P2</span> <span class="o">...</span> <span class="no">T2</span> <span class="no">Tn</span><span class="p">}</span>
  <span class="k">end</span>
  <span class="nb">proc</span> <span class="p">{</span><span class="no">P3</span> <span class="o">...</span> <span class="no">U1</span> <span class="p">?</span><span class="no">Un</span><span class="p">}</span>
    <span class="o">...</span>
    <span class="p">{</span><span class="no">P2</span> <span class="o">...</span> <span class="no">U1</span> <span class="no">U2</span><span class="p">}</span>
    <span class="p">{</span><span class="no">P3</span> <span class="o">...</span> <span class="no">U2</span> <span class="no">Un</span><span class="p">}</span>
  <span class="k">end</span> 
<span class="k">in</span>
  <span class="sb">`export`</span><span class="p">(</span><span class="n">p1</span><span class="ss">:P1</span> <span class="n">p2</span><span class="ss">:P2</span> <span class="n">p3</span><span class="p">:</span><span class="no">P3</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>In a stateful language, the same could be achieved by changing no procedure signatures. Incrementing would be done at the call site, and a variable would be made available globally upon program instantiation. Consider a bit of Ruby code:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Work</span>
  <span class="k">def</span> <span class="nf">part_one</span>
    <span class="o">...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">part_two</span>
    <span class="o">...</span>
    <span class="n">part_one</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">part_two</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">part_three</span>
    <span class="o">...</span>
    <span class="n">part_two</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">part_three</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>And the instrumented version:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Work</span>
  <span class="vc">@@counter</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="nf">part_one</span>
    <span class="vc">@@counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="o">...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">part_two</span>
    <span class="o">...</span>
    <span class="n">part_one</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">part_two</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">part_three</span>
    <span class="o">...</span>
    <span class="n">part_two</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">part_three</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>No method signatures change, and significantly, the only places you see change are where you‚Äôd expect them.</p>

<h4 id="example-sql-queries">Example: SQL Queries</h4>

<p>Professional developers who write applications which interact with traditional databases are familiar with the pattern of embedding declarative nuggets in the screaming abyss of their imperative Java, Ruby, Python, or PHP code. SQL is the ‚Äúwhat‚Äù without the ‚Äúhow‚Äù and has a way of being understandable on its own without needing to understand its surrounding context. Queries which select certain fields from certain rows in a certain way will always do just that.</p>

<p>There is an interesting correspondence between how queries embedded in application code crystallize and come to <em>represent the data they retrieve</em> and the referential transparency of mathematical functions. Other tokens in stateful Object Oriented languages, for example are not nearly as reliable. So much more context is necessary to decipher even highly localized pieces of code in what have become the standard for modern Object Oriented applications, particularly in web platforms. Declarativeness is a tool that can be reached for more, a point which the authors drive home quite heavily at the end of Chapter 4.</p>

<h4 id="example-haskell">Example: Haskell</h4>

<p>One of the more interesting aspects of Chapters 3 and 4 is the extended treatment of the Haskell programming language. According to the authors,</p>

<blockquote>
  <p>‚ÄúHaskell is perhaps the most successful attempt to define a practical, completely declarative language.‚Äù</p>
</blockquote>

<p>The introduction to the language at this point in the book is very interesting, because it serves as a contrast to the available declarative kernel, and illustrates deep connections between Haskell‚Äôs design and the goals of declarative computation. By showing how compact and powerful Haskell code is, the authors provide another alternative for developers ‚Äústuck‚Äù in the imperative world - look for services or pieces of your data flow which can be replaced by something declarative - you‚Äôll be happy you put in the effort. I also found it fascinating as someone who came to CTM with an understanding of what <em>functional</em> meant, but not a very solid understanding of what it means to be <em>declarative.</em> Pure functional programming is a specific case of Declarative programming, a fact that has far reaching implications and is precisely the kind of insight that has gotten me so hooked on this book.</p>

<h4 id="conclusions">Conclusions</h4>

<p>Declarativeness is a property of code which subsumes what professional developers typically refer to as <em>functional</em> and <em>purely functional</em> code. While real world applications don‚Äôt allow us to solely rely on declarative code to solve all of our problems, we can embrace its positive qualities and learn to overcome its shortcomings by following two basic approaches: embedding and extending. As we have shown, we can embed declarative code within our imperative codebases if we are sure to protect the boundaries between the two.</p>

<p>Extending the declarative model to include properties for concurrency, for example, can help make declarative code more realistic for application in real world programs. Declarative concurrency is a fascinating subject which has a deep history, and in covering it with the next post, will pause our in depth study of the declarative paradigm as we move on to Message Passing Concurrency in Chapter 5.</p>

<h4 id="works-cited">Works Cited</h4>

<p><em>All quotes from:</em></p>

<p><a id="bib1">[1]</a> Van Roy and Haridi. <em>Concepts, Techniques, and Models of Computer Programming</em> MIT Press, hardcover, ISBN 0-262-22069-5, March 2004</p>

:ET
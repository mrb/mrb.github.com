I"Ú&<p>#
#</p>
<h3 id="meeting-j-bob-notes-on-the-little-prover-chapters-1-5">Meeting J-Bob: Notes on ‚ÄúThe Little Prover‚Äù Chapters 1-5</h3>

<p><a href="http://www.cs.indiana.edu/~dfried/">Daniel P. Friedman</a> has authored or co-authored an alarming number of Computer Science books that Programming Language enthusiasts would consider classics. Among them are a few members of the series of ‚ÄúLittle‚Äù books, which started in the 70s with ‚ÄúThe Little LISPer,‚Äù and continues 40 years later, with 2015‚Äôs ‚ÄúThe Little Prover,‚Äù co-authored with Carl Eastlund.</p>

<p>All of the ‚ÄúLittle‚Äù books follow a similar structure and embrace a similar pedagogy: concepts are taught through a series of questions and answers side by side, presented in ‚Äúframes‚Äù separated by lines. I have studied some of the other books before, particularly ‚ÄúThe Reasoned Schemer‚Äù (which doesn‚Äôt have the word ‚ÄúLittle‚Äù in it but is still a part of the ‚Äòseries‚Äô), but have never really clicked with how the information is presented.</p>

<p>Probably because I had a good reason to feel that I <em>needed</em> to understand what they were presenting, the technique finally worked for me with ‚ÄúThe Little Prover.‚Äù Reading the pages over and over again I got into a rhythm and started to absorb the information. Another thing that was blocking me before was a lack of intuitive understanding of Scheme (pairs and lists everywhere confused me, <code class="language-plaintext highlighter-rouge">cons</code> and <code class="language-plaintext highlighter-rouge">car</code> and <code class="language-plaintext highlighter-rouge">cdr</code> irked me). For some reason, that vanished for me too when I started with this book, so yay! It only took me around 8 years to be able to digest Scheme properly. Not too shabby, mrb, not too shabby.</p>

<p>Why was I so compelled to grok this stuff? I committed myself to presenting about Phillip Wadler‚Äôs ‚ÄúPropositions as Types‚Äù at the New York City chapter of Papers We Love, and I wanted to have a concrete, interactive experience to go along with the theory and mechanics I was trying to grasp from the paper. ‚ÄúThe Little Prover‚Äù coming out around the same time as I was preparing seemed serendipitous - it describes a theorem prover written in Scheme and shows how theorem proving and writing Scheme code can actually be the same thing.</p>

<p>To put a finer point it, I love this book and highly recommend it. It has lots of lessons to teach, which aren‚Äôt limited to theorem provers. What the authors can do with a ‚Äòsimple‚Äô system written in Scheme is phenomenal and very deep, and importantly, challenging concepts are made fun and easy to access given enough time and patience. I found pieces of some of my favorite aspects of philosophy, math, and Computer Science in the book, and think you can make connections to:</p>

<ul>
  <li>Compilers</li>
  <li>Static Analysis</li>
  <li>Logic</li>
  <li>Language and truth (what is like, real‚Ä¶man?)</li>
  <li>Kernel languages</li>
  <li>Small things</li>
  <li>Breakfast</li>
</ul>

<p>And I‚Äôm pretty sure if you‚Äôre reading this, you like at least some of those things.</p>

<p>I decided to write down some notes and musings from each of the 10 chapters in the book in order to bolster my understanding, provide an artifact of my learning in case anything becomes fuzzy to me later (which it certainly will, given historical evidence), and to prove to myself that I can explain this stuff in the context of Wadler‚Äôs paper. This post covers the first 5 chapters. For each one, I‚Äôve written down what the ‚ÄúBig ideas‚Äù were for me - what resonated, what I think the authors were after, and what I could take away. Here we go!</p>

<p><em>Note: There is some Scheme code below that is illustrative, and some that is meant to be executed by the J-Bob proof assistant, the design and implementation of which is one of the central focuses of the book. Understanding which is which is a little bit confusing, but check out <a href="http://github.com/the-little-prover/j-bob">The J-Bob Source Code on GitHub</a> for some clues.</em></p>

<h2 id="chapter-1---old-games-new-rules">Chapter 1 - Old Games, New Rules</h2>

<p><em>Big ideas:</em></p>

<ul>
  <li>We can know cool things about a program without having to run it</li>
  <li>Rewriting programs according to rules is powerful and pervasive</li>
  <li>You can prove theorems by writing code</li>
  <li>Holy shit I finally understand Scheme</li>
</ul>

<p>The Scheme code <code class="language-plaintext highlighter-rouge">(car (cons 'ham '(eggs)))</code> is <em>equal to</em> to <code class="language-plaintext highlighter-rouge">'ham</code>.</p>

<p>Each of the following lines of Scheme code are also <em>equal to</em> <code class="language-plaintext highlighter-rouge">'ham</code>:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">'ham</span> <span class="o">'</span><span class="p">(</span><span class="nf">cheese</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">'eggs</span> <span class="o">'</span><span class="p">(</span><span class="nf">ham</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="o">'</span><span class="p">(</span><span class="nf">ham</span><span class="o">'</span><span class="p">))</span> <span class="o">'</span><span class="p">(</span><span class="nf">eggs</span><span class="o">'</span><span class="p">)))</span></code></pre></figure>

<p>The Scheme code <code class="language-plaintext highlighter-rouge">(car (cons 'ham '(eggs)))</code> is <em>equal to the value</em> <code class="language-plaintext highlighter-rouge">'ham</code>. It is not equal to <em>any other value</em>.</p>

<p>What value is the Scheme code <code class="language-plaintext highlighter-rouge">(cons a b)</code> <em>equal to</em>? We don‚Äôt know what <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are, so we can‚Äôt know the value of <code class="language-plaintext highlighter-rouge">(cons a b)</code>.</p>

<p>An <code class="language-plaintext highlighter-rouge">atom</code> in Scheme is defined as anything that is not a <code class="language-plaintext highlighter-rouge">pair</code>, and a <code class="language-plaintext highlighter-rouge">pair</code> is something that is produced with <code class="language-plaintext highlighter-rouge">cons</code>. This should give you the idea:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">atom?</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="ss">'t</span>
<span class="p">(</span><span class="nf">atom?</span> <span class="ss">'nil</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="ss">'t</span>
<span class="p">(</span><span class="nf">atom?</span> <span class="o">'</span><span class="p">())</span> <span class="nv">=&gt;</span> <span class="ss">'t</span>
<span class="p">(</span><span class="nf">atom?</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="ss">'nil</span>
<span class="p">(</span><span class="nf">atom?</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="ss">'nil</span></code></pre></figure>

<p>Play around in your friendly Scheme REPL if you feel like testing more expressions. I‚Äôve certainly spent long enough doing so, I wouldn‚Äôt want to begrudge you the fun!</p>

<p>So, back to the question ‚ÄúWhat is the value of <code class="language-plaintext highlighter-rouge">(atom? (cons a b))</code>?‚Äù</p>

<p>Even though we don‚Äôt know <em>what</em> <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are, we know the value of <code class="language-plaintext highlighter-rouge">(atom? (cons a b))</code> - why?</p>

<p>Because we know the definition of <code class="language-plaintext highlighter-rouge">atom?</code>, which returns <code class="language-plaintext highlighter-rouge">'nil</code> for anything that is the result of a <code class="language-plaintext highlighter-rouge">cons</code> operation.</p>

<p>So the value of <code class="language-plaintext highlighter-rouge">(atom? (cons a b))</code> is <code class="language-plaintext highlighter-rouge">'nil</code>, regardless of the values of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. This is cool, and reminds me of static analysis.</p>

<p>Does the expression <code class="language-plaintext highlighter-rouge">(equal? 'flapjack (atom? (cons a b)))</code> have a value?</p>

<p>If we know that <code class="language-plaintext highlighter-rouge">(atom? (cons a b))</code> is <code class="language-plaintext highlighter-rouge">'nil</code>, does that help us? It does! We can substitute <code class="language-plaintext highlighter-rouge">'nil</code> for any instance of <code class="language-plaintext highlighter-rouge">(atom? (cons a b))</code> that we come across. That seems useful.</p>

<p>So <code class="language-plaintext highlighter-rouge">(equal? 'flapjack (atom? (cons a b)))</code> becomes <code class="language-plaintext highlighter-rouge">(equal? 'flapjack 'nil)</code> which is <code class="language-plaintext highlighter-rouge">'nil</code>.</p>

<p>The big idea here is that:</p>

<blockquote>
  <p>We can know interesting things about a program without executing it.</p>
</blockquote>

<p>The authors are also introducing the idea of a <strong>focus</strong> within a piece of code that is being transformed/evaluated in this strange new way.</p>

<p>Our attention is drawn to the fact that this transformation happens <em>in discrete steps</em> and rewriting is applied <em>to specific, addressable subexpressions</em> of the term at hand. To follow these steps:</p>

<ol>
  <li>Starting from the code <code class="language-plaintext highlighter-rouge">(equal? 'flapjack (atom? (cons a b)))</code>, the  focus is <code class="language-plaintext highlighter-rouge">(atom? (cons a b))</code>, which we can rewrite to <code class="language-plaintext highlighter-rouge">'nil</code>.</li>
  <li>After the substitution occurs, the  <strong>focus</strong> is on the whole expression, which is <code class="language-plaintext highlighter-rouge">(equal? 'flapjack 'nil)</code>. We know this is equal to <code class="language-plaintext highlighter-rouge">'nil</code>.</li>
</ol>

<p>So two steps and two focuses later, we have reduced the original expression to a value without having to know everything about that program, e.g. the values of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>.</p>

<p>We relied on certain known facts in order to execute the above transformation. These facts are called <em>axioms</em>.</p>

<blockquote>
  <p>‚ÄúAn axiom is a basic assumption that is presumed to be true.‚Äù</p>
</blockquote>

<p>Here are some axioms:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">(atom? (cons x y))</code> is always equal to <code class="language-plaintext highlighter-rouge">'nil</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">(car (cons x y))</code> is always equal to <code class="language-plaintext highlighter-rouge">x</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">(cdr (cons x y))</code> is always equal to <code class="language-plaintext highlighter-rouge">y</code>.</li>
</ol>

<p>Stated in code, using the <code class="language-plaintext highlighter-rouge">dethm</code> construct:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">dethm</span> <span class="nv">atom/cons</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">equal?</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="ss">'nil</span><span class="p">))</span></code></pre></figure>

<p>When axioms are built up to prove things, that‚Äôs called a <em>theorem</em>:</p>

<blockquote>
  <p>‚ÄúA theorem is an expression that is always true.‚Äù</p>
</blockquote>

<p>And to put a finer point on it:</p>

<blockquote>
  <p>‚ÄúAxioms are theorems that are assumed to be true, whereas other theorems must be shown to be true.‚Äù</p>
</blockquote>

<p>Here are the steps of rewriting the following expression until it becomes <code class="language-plaintext highlighter-rouge">'t</code>:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nb">car</span>
  <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
    <span class="o">'</span><span class="p">(</span><span class="k">and</span> <span class="nv">crumpets</span><span class="p">)))</span></code></pre></figure>

<p>We notice that <code class="language-plaintext highlighter-rouge">(equal (cons x y) (cons x y))</code> will always be <code class="language-plaintext highlighter-rouge">'t</code>, regardless of what <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> are. So, we can replace it with <code class="language-plaintext highlighter-rouge">'t</code>:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nb">car</span>
  <span class="p">(</span><span class="nb">cons</span> <span class="ss">'t</span>
    <span class="o">'</span><span class="p">(</span><span class="k">and</span> <span class="nv">crumpets</span><span class="p">)))</span></code></pre></figure>

<p>Likewise, the static values <code class="language-plaintext highlighter-rouge">'t</code> and <code class="language-plaintext highlighter-rouge">'(and crumpets)</code> can be collapsed using <code class="language-plaintext highlighter-rouge">cons</code>. Finally:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nb">car</span> <span class="o">'</span><span class="p">(</span><span class="ss">'t</span> <span class="nv">and</span> <span class="nv">crumpets</span><span class="p">))</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">car</code> of <code class="language-plaintext highlighter-rouge">'('t and crumpets)</code> will always be <code class="language-plaintext highlighter-rouge">'t</code>. So we arrive at:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="ss">'t</span></code></pre></figure>

<p>Without executing the code, we know that it will always evaluate to <code class="language-plaintext highlighter-rouge">'t</code>.</p>

<p>The Law of Dethm (initial):</p>

<blockquote>
  <p>‚ÄúFor any theorem <code class="language-plaintext highlighter-rouge">(dethm name (x1...xn) body-x)</code>, the variables <code class="language-plaintext highlighter-rouge">x1...xn</code> in <code class="language-plaintext highlighter-rouge">body-x</code> can be replaced with any corresponding expressions <code class="language-plaintext highlighter-rouge">e1...en</code>. The result, <code class="language-plaintext highlighter-rouge">body-e</code>, can be used to rewrite a focus <code class="language-plaintext highlighter-rouge">p</code> to become <code class="language-plaintext highlighter-rouge">q</code> provided <code class="language-plaintext highlighter-rouge">body-e</code> is either <code class="language-plaintext highlighter-rouge">(equal? p q)</code> or <code class="language-plaintext highlighter-rouge">(equal? q p).</code>‚Äù</p>
</blockquote>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">atom?</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">b</span><span class="p">))))</span>

<span class="nv">e1</span> <span class="nv">-&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">a</span><span class="p">)</span>
<span class="nv">e2</span> <span class="nv">-&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">b</span><span class="p">)</span>

<span class="nv">body-e</span> <span class="nv">-&gt;</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">b</span><span class="p">)))</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">a</span><span class="p">))</span>

<span class="nv">p</span> <span class="nv">-&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">b</span><span class="p">)))</span>
<span class="nv">q</span> <span class="nv">-&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">a</span><span class="p">)</span>

<span class="p">(</span><span class="nf">atom?</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">a</span><span class="p">))</span></code></pre></figure>

<p>That‚Äôs what it looks like to apply the Law of Dethm to some functions. We‚Äôre also told that J-Bob, an assistant in the form of a computer program, can help us automatically do some of these transformations.</p>

<h2 id="chapter-2---even-older-games">Chapter 2 - Even Older Games</h2>

<p><em>Big ideas:</em></p>

<ul>
  <li>Theorems in the system are written according to the <code class="language-plaintext highlighter-rouge">Law of Dethm</code></li>
  <li>Using an abstract example to understand a deep principle is helpful - see <code class="language-plaintext highlighter-rouge">The Jabberwocky</code></li>
  <li>We will be able to prove conjectures using a library of axioms</li>
</ul>

<p>What is <code class="language-plaintext highlighter-rouge">(car (cons a b))</code> in this code equal to?</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
  <span class="nv">c</span>
  <span class="nv">c</span><span class="p">)</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">a</code>, since the <code class="language-plaintext highlighter-rouge">car</code> of <code class="language-plaintext highlighter-rouge">(cons a b)</code> is always <code class="language-plaintext highlighter-rouge">a</code>. This is the result:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">if</span> <span class="nv">a</span>
  <span class="nv">c</span>
  <span class="nv">c</span><span class="p">)</span></code></pre></figure>

<p>We know we can do that because of the axiom of <code class="language-plaintext highlighter-rouge">car/cons</code>. What is the expression above equal to?</p>

<p>The result is <code class="language-plaintext highlighter-rouge">c</code>, regardless of <code class="language-plaintext highlighter-rouge">a</code>. Chapter 2 introduces axions around <code class="language-plaintext highlighter-rouge">if</code> to help us rewrite <code class="language-plaintext highlighter-rouge">if</code> code the same way that we rewrote with <code class="language-plaintext highlighter-rouge">car/cons</code> above.</p>

<p>The axioms of If: <code class="language-plaintext highlighter-rouge">if-true</code>, <code class="language-plaintext highlighter-rouge">if-false</code>, <code class="language-plaintext highlighter-rouge">if-same</code>:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">dethm</span> <span class="nv">if-true</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="k">if</span> <span class="ss">'t</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>
  
<span class="p">(</span><span class="nf">dethm</span> <span class="nv">if-false</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="k">if</span> <span class="ss">'nil</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">y</span><span class="p">))</span>
  
<span class="p">(</span><span class="nf">dethm</span> <span class="nv">if-same</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">y</span><span class="p">))</span></code></pre></figure>

<p>These axioms each represent very simple ideas that turn out to have very powerful implications.</p>

<p>Every <code class="language-plaintext highlighter-rouge">if</code> expression has three parts: <code class="language-plaintext highlighter-rouge">(if Q A E)</code>: The Question, the Answer, and the Else.</p>

<p>The axioms of Equal: <code class="language-plaintext highlighter-rouge">equal-same</code>, <code class="language-plaintext highlighter-rouge">equal-swap</code>, <code class="language-plaintext highlighter-rouge">equal-if</code>.</p>

<p>The Law of Dethm (final)</p>

<ul>
  <li>For any theorem <code class="language-plaintext highlighter-rouge">(dethm name (x1...xn) body-x)</code>:</li>
  <li>The variables <code class="language-plaintext highlighter-rouge">x1...xn</code> in <code class="language-plaintext highlighter-rouge">body-x</code> can be replaced with any corresponding expressions <code class="language-plaintext highlighter-rouge">e1...en</code>.</li>
  <li>The result, <code class="language-plaintext highlighter-rouge">body-e</code>, can be used to rewrite a focus as follows:
    <ol>
      <li><code class="language-plaintext highlighter-rouge">body-e</code> must contain the <em>conclusion</em></li>
      <li>The <em>conclusion</em> must not be found:</li>
      <li>in the <code class="language-plaintext highlighter-rouge">Q</code> of any <code class="language-plaintext highlighter-rouge">if</code></li>
      <li>in the argument of any function application</li>
      <li>if the <em>conclusion</em> can be found in an <code class="language-plaintext highlighter-rouge">if</code> <code class="language-plaintext highlighter-rouge">A</code> or <code class="language-plaintext highlighter-rouge">E</code>, then the <em>focus</em> must be found in an <code class="language-plaintext highlighter-rouge">if</code> <code class="language-plaintext highlighter-rouge">A</code> or <code class="language-plaintext highlighter-rouge">E</code> with the same <code class="language-plaintext highlighter-rouge">Q</code>.</li>
    </ol>
  </li>
</ul>

<p>Explaining the ‚ÄúLaw of Dethm‚Äù with the Jabberwocky example:</p>

<blockquote>
  <p>‚ÄúSometimes our intuitions get in the way.‚Äù</p>
</blockquote>

<p>The <code class="language-plaintext highlighter-rouge">if-nest</code> axioms are amazing:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">dethm</span> <span class="nv">if-nest-A</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span> <span class="ss">'t</span><span class="p">))</span>
  
<span class="p">(</span><span class="nf">dethm</span> <span class="nv">if-nest-E</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="k">if</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span> <span class="nv">z</span><span class="p">)</span> <span class="ss">'t</span><span class="p">))</span></code></pre></figure>

<p>Reminds me of the first time I realized that statically typing terms of certain dynamic languages was possible. Consider the following snippet:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="nv">function</span> <span class="nv">fooTester</span> <span class="p">(</span><span class="nf">foo</span><span class="p">)</span><span class="err">{</span>
  <span class="nv">if</span> <span class="p">(</span><span class="nf">foo</span> <span class="nv">&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="err">{</span>
    <span class="nv">return</span> <span class="s">"cool"</span><span class="c1">;</span>
  <span class="err">}</span> <span class="nv">else</span> <span class="err">{</span>
      <span class="nv">return</span> <span class="s">"uncool"</span><span class="c1">;</span>
  <span class="err">}</span>
<span class="err">}</span></code></pre></figure>

<p>Think about it long enough and you can see that there are both assumptions that can be made about the types in this function, and also some things you know. An assumption is that <code class="language-plaintext highlighter-rouge">foo</code> is a number. We test it against <code class="language-plaintext highlighter-rouge">3</code> using the <code class="language-plaintext highlighter-rouge">&gt;</code> operator, which we know operates on numbers.</p>

<p>Something we  know for sure is that this function returns a <code class="language-plaintext highlighter-rouge">String</code>. Regardless of the value of <code class="language-plaintext highlighter-rouge">foo</code>, this <code class="language-plaintext highlighter-rouge">if</code> expression returns a <code class="language-plaintext highlighter-rouge">String</code>.</p>

<p>Start to stack these assumptions up, dream of an interactive tool that can tell you the types of these expressions without having to know them, and throw in a type checker that can assert what you annotate, and you can get a sense of a pathway from dynamic to statically typed programming.</p>

<p>In this chapter we also get <code class="language-plaintext highlighter-rouge">The Axioms of Cons</code>, <code class="language-plaintext highlighter-rouge">atom/cons</code>, <code class="language-plaintext highlighter-rouge">car/cons</code>, <code class="language-plaintext highlighter-rouge">cdr/cons</code>:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">dethm</span> <span class="nv">atom/cons</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="ss">'nil</span><span class="p">))</span>

<span class="p">(</span><span class="nf">dethm</span> <span class="nv">car/cons</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nf">dethm</span> <span class="nv">cdr/cons</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">y</span><span class="p">)</span></code></pre></figure>

<p>More intuitive but not intuitive facts about list construction in Scheme than you knew were useful. This chapter really nails the fluid, bizarre methods of applying rules and rewriting code that goes into creating mechanized proofs on a computer using a programming language.</p>

<p>Through applying some sensical and some nonsensical techniques, the authors illustrate that like programming, you can gain an intuition for the idioms of theorem proving through repetition and deep understanding. Write and read enough programs and you‚Äôll learn how to write programs properly. Write and read enough proofs, it seems, and the same will happen. An interesting perspective on the correspondences that make the ideas in this book possible.</p>

<h2 id="chapter-3---whats-in-a-name">Chapter 3 - What‚Äôs in a Name?</h2>

<p><em>Big ideas:</em></p>

<ul>
  <li>A claim is an unproven theorem</li>
  <li>J-Bob can help you prove that your claims are theorems</li>
  <li>J-Bob has a language for describing how to rewrite code</li>
</ul>

<p>The value of the Scheme code <code class="language-plaintext highlighter-rouge">(pair 'sharp 'cheddar)</code> is <code class="language-plaintext highlighter-rouge">'(sharp cheddar)</code>.</p>

<p>The value of <code class="language-plaintext highlighter-rouge">(first-of (pair 'sharp 'cheddar))</code> is <code class="language-plaintext highlighter-rouge">'sharp</code>.</p>

<p>The value of <code class="language-plaintext highlighter-rouge">(second-of (pair 'sharp 'cheddar))</code> is <code class="language-plaintext highlighter-rouge">'cheddar</code>.</p>

<p>The function <code class="language-plaintext highlighter-rouge">pair</code> is written like this:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pair</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">y</span> <span class="o">'</span><span class="p">())))</span></code></pre></figure>

<p>And here‚Äôs <code class="language-plaintext highlighter-rouge">first-of</code> and <code class="language-plaintext highlighter-rouge">second-of</code>:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">first-of</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">))</span>
  
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">second-of</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))</span></code></pre></figure>

<p>Here‚Äôs a claim about <code class="language-plaintext highlighter-rouge">first-of</code>:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">dethm</span> <span class="nv">first-of-pair</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">first-of</span> <span class="p">(</span><span class="nf">pair</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">a</span><span class="p">))))</span></code></pre></figure>

<blockquote>
  <p>‚ÄúA claim is an as-yet unproven theorem.‚Äù</p>
</blockquote>

<p>We can make a claim into a theorem! By <em>proving</em> it!</p>

<blockquote>
  <p>‚ÄúA proof is a sequence of rewriting steps that ends in <code class="language-plaintext highlighter-rouge">'t</code>. If we can rewrite a claim, step by step, to <code class="language-plaintext highlighter-rouge">'t</code>, then that claim is a theorem.‚Äù</p>
</blockquote>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">pair</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">-&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">y</span> <span class="o">'</span><span class="p">()))</span>

<span class="p">(</span><span class="nf">pair</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">-&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">b</span> <span class="o">'</span><span class="p">()))</span></code></pre></figure>

<p>Defun: Given the non-recursive function <code class="language-plaintext highlighter-rouge">(defun name (x1...xn) body)</code>, <code class="language-plaintext highlighter-rouge">(name e1...en) = body</code> where <code class="language-plaintext highlighter-rouge">x1</code> is <code class="language-plaintext highlighter-rouge">e1,...xn is en</code>.</p>

<p>In other words, for a non-recursive function, you can replace the <code class="language-plaintext highlighter-rouge">function call</code> with the <code class="language-plaintext highlighter-rouge">function definition</code>, substituting the arguments from the definition with those of the function you‚Äôre proving.</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">first-of</span> <span class="p">(</span><span class="nf">pair</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
<span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">first-of</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">b</span> <span class="o">'</span><span class="p">())))</span> <span class="nv">a</span><span class="p">)</span>
<span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">b</span> <span class="o">'</span><span class="p">())))</span> <span class="nv">a</span><span class="p">)</span>
<span class="p">(</span><span class="nf">equal</span> <span class="nv">a</span> <span class="nv">a</span><span class="p">)</span>
<span class="p">(</span><span class="ss">'t</span><span class="p">)</span></code></pre></figure>

<p>So <code class="language-plaintext highlighter-rouge">first-of-pair</code> is a theorem, by <code class="language-plaintext highlighter-rouge">Law of Defun</code>, <code class="language-plaintext highlighter-rouge">car/cons</code>, and <code class="language-plaintext highlighter-rouge">equal-same</code>.</p>

<p>Is <code class="language-plaintext highlighter-rouge">second-of-pair</code> a theorem?</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">dethm</span> <span class="nv">second-of-pair</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">second-of</span> <span class="p">(</span><span class="nf">pair</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span> <span class="nv">b</span><span class="p">)</span></code></pre></figure>

<p>Yes, by <code class="language-plaintext highlighter-rouge">car/cons</code>, <code class="language-plaintext highlighter-rouge">cdr/cons</code>, <code class="language-plaintext highlighter-rouge">equal-same</code>, <code class="language-plaintext highlighter-rouge">second-of</code>, and <code class="language-plaintext highlighter-rouge">pair</code>.</p>

<p>For the first three chapters, the authors cleverly use colors in the printed text to show the ‚Äúfocus‚Äù of an expression as it is being rewritten.</p>

<p>When you are using the J-Bob prover that the book introduces and shows you how to use and implement, you describe these focuses using a query language of sorts describing the ‚Äúpath‚Äù to the part of the expression that needs to be rewritten.</p>

<p>This works because all code is a list. ‚ÄúCode as data‚Äù in the Lisp tradition has a lot of awesome applications and the authors of this book, one of whom is easily one of the deepest functional programming thinkers of all time, leverage this property to the fullest in this text.</p>

<blockquote>
  <p>‚ÄúIf we can find a proof one way, we can always find it in another. If the second way goes wrong, we can ‚Äòback up‚Äô to where we started and do it the first way again. But some approaches will find a proof faster than others.‚Äù</p>
</blockquote>

<p>Let‚Äôs look at <code class="language-plaintext highlighter-rouge">in-pair?</code>. What does it do?</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">defun</span> <span class="nv">in-pair?</span> <span class="p">(</span><span class="nf">xs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">first-of</span> <span class="nv">xs</span><span class="p">)</span> <span class="ss">'?</span><span class="p">)</span>
    <span class="ss">'t</span>
    <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">second-of</span> <span class="nv">xs</span><span class="p">)</span> <span class="ss">'?</span><span class="p">)))</span></code></pre></figure>

<p>It determines whether the two-element list <code class="language-plaintext highlighter-rouge">xs</code> contains <code class="language-plaintext highlighter-rouge">'?</code>. Let‚Äôs try to prove this claim!</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">dethm</span> <span class="nv">in-first-of-pair</span> <span class="p">(</span><span class="nf">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">in-pair?</span> <span class="p">(</span><span class="nf">pair</span> <span class="ss">'?</span> <span class="nv">b</span><span class="p">))</span> <span class="ss">'t</span><span class="p">))</span></code></pre></figure>

<p>Is <code class="language-plaintext highlighter-rouge">in-first-of-pair</code> a theorem? Yes! By <code class="language-plaintext highlighter-rouge">car/cons</code>, <code class="language-plaintext highlighter-rouge">equal-same</code>, <code class="language-plaintext highlighter-rouge">if-true</code>, <code class="language-plaintext highlighter-rouge">pair</code>, <code class="language-plaintext highlighter-rouge">in-pair?</code> and <code class="language-plaintext highlighter-rouge">first-of</code>.</p>

<blockquote>
  <p>‚ÄúSkip irrelevant examples: Rewriting a claim to ‚Äòt does not have to go in any particular order.‚Äù</p>
</blockquote>

<p>This chapter shows us the mechanics of using code to prove theorems, which are expressed as code. These proofs happen by rewriting code using pre-defined rules to begin with a conjecture and then end with <code class="language-plaintext highlighter-rouge">'t</code>, which completes the proof.</p>

<h2 id="chapter-4---part-of-this-total-breakfast">Chapter 4 - Part of This Total Breakfast</h2>

<p><em>Big ideas:</em></p>

<ul>
  <li>J-Bob can be used to prove the totality of functions, recursive or not</li>
  <li>Proving totality of functions with natural recursion uses J-Bob‚Äôs <code class="language-plaintext highlighter-rouge">size</code> function, and is a neat way to prove totality</li>
  <li>Partial functions are problematic because they can be used to introduce inconsistencies into a system</li>
</ul>

<p>We meet a new function - <code class="language-plaintext highlighter-rouge">list0?</code>. Here‚Äôs how it works:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">list0?</span> <span class="ss">'oatmeal</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="ss">'nil</span>
<span class="p">(</span><span class="nf">list0?</span> <span class="o">'</span><span class="p">())</span> <span class="nv">=&gt;</span> <span class="ss">'t</span>
<span class="p">(</span><span class="nf">list0?</span> <span class="o">'</span><span class="p">(</span><span class="nf">toast</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="ss">'nil</span></code></pre></figure>

<p>What does <code class="language-plaintext highlighter-rouge">list0?</code> do? It looks like it tells you if something is an empty list. Here is the definition:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">defun</span> <span class="nv">list0?</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="nv">x</span> <span class="o">'</span><span class="p">()))</span></code></pre></figure>

<p>Is <code class="language-plaintext highlighter-rouge">list0?</code> total? What does total mean?</p>

<blockquote>
  <p>‚Äú<code class="language-plaintext highlighter-rouge">list0?</code> is total means that no matter what value <code class="language-plaintext highlighter-rouge">v</code> is passed to <code class="language-plaintext highlighter-rouge">list0?</code>, the expression <code class="language-plaintext highlighter-rouge">(list0? v)</code> has a value.‚Äù</p>
</blockquote>

<p>In other words a function <code class="language-plaintext highlighter-rouge">f</code> composed of functions <code class="language-plaintext highlighter-rouge">x1...xn</code> and if statements <code class="language-plaintext highlighter-rouge">if1...ifn</code> can be total if all of the outcomes of <code class="language-plaintext highlighter-rouge">if1...ifn</code> produce a value and <code class="language-plaintext highlighter-rouge">x1...xn</code> are all total.</p>

<p>We learn that, somewhat surprisingly, all built in operators are total. When we‚Äôre trying to determine if a function is total, we know that all functions used in a function must be total for a function to be total. For example:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">defun</span> <span class="nv">list1?</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">x</span><span class="p">)</span>
  <span class="ss">'nil</span>
  <span class="p">(</span><span class="nf">list0?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))))</span></code></pre></figure>

<p>Is total because <code class="language-plaintext highlighter-rouge">atom</code>, <code class="language-plaintext highlighter-rouge">list0?</code>, and <code class="language-plaintext highlighter-rouge">cdr</code> are all total, and the if statements <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">E</code> produce a value. Now that we know what totality is, we can learn about the final <code class="language-plaintext highlighter-rouge">Law of Defun</code>:</p>

<blockquote>
  <p>‚ÄúGiven the total function (defun name (x1‚Ä¶xn) body), (name e1‚Ä¶en) = body where x1 is e1, ‚Ä¶, xn is en.‚Äù</p>
</blockquote>

<p>In other words, we can replace a function‚Äôs use with it‚Äôs body (once variable substitutions are performed) if the function is total. Why does it matter if it is total? If it isn‚Äôt, a function can be used to prove a contradiction. Let‚Äôs take a look.</p>

<p>We go through the process of trying to prove <code class="language-plaintext highlighter-rouge">list0?</code>, <code class="language-plaintext highlighter-rouge">list1?</code>, <code class="language-plaintext highlighter-rouge">list2?</code>, <code class="language-plaintext highlighter-rouge">list3?</code>, etc. as total. There must be an easier way, and it sounds like a job for recursion. Can we use recursion like that? What would that look like? How about like this:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">defun</span> <span class="nv">list?</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">equal</span> <span class="nv">x</span> <span class="o">'</span><span class="p">())</span>
    <span class="p">(</span><span class="nb">list?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))))</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">list?</code> function produces <code class="language-plaintext highlighter-rouge">'t</code> if its argument is a list, otherwise it produces <code class="language-plaintext highlighter-rouge">'nil</code>. So, is <code class="language-plaintext highlighter-rouge">list?</code> total?</p>

<p>It looks like in order to know if <code class="language-plaintext highlighter-rouge">list?</code> is total, we need to know if <code class="language-plaintext highlighter-rouge">list?</code> is total, because the function is recursive. So what can we know about how <code class="language-plaintext highlighter-rouge">list?</code> is called from within <code class="language-plaintext highlighter-rouge">list?</code>?</p>

<p>We see that <code class="language-plaintext highlighter-rouge">list?</code> is always called with <code class="language-plaintext highlighter-rouge">(cdr x)</code> as its argument. That means that by definition, calls to <code class="language-plaintext highlighter-rouge">list?</code> from within <code class="language-plaintext highlighter-rouge">list?</code> always have fewer <code class="language-plaintext highlighter-rouge">conses</code> than the function started with.</p>

<p>The way that we use this fact to prove that <code class="language-plaintext highlighter-rouge">list?</code> is total is with a mechanism known as the <code class="language-plaintext highlighter-rouge">measure</code> of a function.</p>

<blockquote>
  <p>‚ÄúThe measure is an expression that is included with a function definition. It may only refer to previously defined, total functions and to the function definition‚Äôs formal arguments. The measure must produce a natural number that decreases for every recursive call to the function.‚Äù</p>
</blockquote>

<p>So if we definte <code class="language-plaintext highlighter-rouge">list?</code> with a measure, J-Bob will know how to measure whether or not recursive calls to a function will actually cause the function to terminate and produce a value.</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">defun</span> <span class="nv">list?</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">equal</span> <span class="nv">x</span> <span class="o">'</span><span class="p">())</span>
    <span class="p">(</span><span class="nb">list?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))))</span>

<span class="nv">measure:</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">)</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">size</code> function measures the size of a function‚Äôs measure. Counting <code class="language-plaintext highlighter-rouge">cons</code> cells, for example:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">size</span> <span class="o">'</span><span class="p">((</span><span class="nf">10</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">20</span><span class="p">))</span> <span class="nv">B</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="ss">'6</span>
<span class="p">(</span><span class="nf">size</span> <span class="o">'</span><span class="p">(</span><span class="nf">10</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">20</span><span class="p">)))</span> <span class="nv">=&gt;</span> <span class="ss">'4</span>
<span class="p">(</span><span class="nf">size</span> <span class="ss">'10</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="ss">'0</span></code></pre></figure>

<p>The way that we make the totality claim for <code class="language-plaintext highlighter-rouge">list?</code> using a measure is by expressing ‚ÄúIf x is not an atom, than <code class="language-plaintext highlighter-rouge">(size x (cdr x))</code> must be smaller than <code class="language-plaintext highlighter-rouge">(size x)</code>.‚Äù</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">natp</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">x</span><span class="p">)</span>
    <span class="ss">'t</span>
    <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nf">size</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">)))</span>
  <span class="ss">'nil</span><span class="p">)</span></code></pre></figure>

<p>We are introduced to some <code class="language-plaintext highlighter-rouge">Axioms of Size</code> which give us certain truths upon which we can rest the burden of our totality claims! Handy.</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">dethm</span> <span class="nv">natp/size</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">natp</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">))</span> <span class="ss">'t</span><span class="p">))</span>
  
<span class="p">(</span><span class="nf">dethm</span> <span class="nv">size/car</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">x</span><span class="p">)</span>
      <span class="ss">'t</span>
        <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nf">size</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">))</span> <span class="ss">'t</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">dethm</span> <span class="nv">size/cdr</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">x</span><span class="p">)</span>
        <span class="ss">'t</span>
        <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nf">size</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">))</span> <span class="ss">'t</span><span class="p">)))</span></code></pre></figure>

<p>So using these rules and the rules we‚Äôve seen before, we can indeed reduce the totality claim above to <code class="language-plaintext highlighter-rouge">'t</code>. Here‚Äôs how it looks using J-Bob:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">defun</span> <span class="nv">defun</span><span class="o">.</span><span class="nv">list?</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">J-Bob/define</span> <span class="p">(</span><span class="nf">defun</span><span class="o">.</span><span class="nv">list2?</span><span class="p">)</span>
    <span class="o">'</span><span class="p">(((</span><span class="nf">defun</span> <span class="nv">list?</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">x</span> <span class="o">'</span><span class="p">())</span> <span class="p">(</span><span class="nb">list?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))))</span>
       <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">)</span>
       <span class="p">((</span><span class="nf">Q</span><span class="p">)</span> <span class="p">(</span><span class="nf">natp/size</span> <span class="nv">x</span><span class="p">))</span>
       <span class="p">(()</span> <span class="p">(</span><span class="nf">if-true</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">'t</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nf">size</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">)))</span> <span class="ss">'nil</span><span class="p">))</span>
       <span class="p">((</span><span class="nf">E</span><span class="p">)</span> <span class="p">(</span><span class="nf">size/cdr</span> <span class="nv">x</span><span class="p">))</span>
       <span class="p">(()</span> <span class="p">(</span><span class="nf">if-same</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">'t</span><span class="p">))))))</span></code></pre></figure>

<p>The totality claim for <code class="language-plaintext highlighter-rouge">partial</code> is as follows:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">the</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">))</span>
  <span class="ss">'t</span>
  <span class="ss">'nil</span><span class="p">)</span>
  <span class="ss">'nil</span><span class="p">)</span></code></pre></figure>

<p>Which can be reduced to:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">x</span><span class="p">))</span>
  <span class="ss">'t</span>
  <span class="ss">'nil</span><span class="p">)</span></code></pre></figure>

<p>Which can‚Äôt go any further - certainly <code class="language-plaintext highlighter-rouge">(&lt; (size x) (size x))</code> could never be true or reconciled within a consistent system. That‚Äôs why <code class="language-plaintext highlighter-rouge">partial</code> is partial, and why totality matters - because partial functions can introduce inconsistencies into our system.</p>

<h2 id="chapter-5---think-it-over-and-over-and-over">Chapter 5 - Think it Over and Over and Over</h2>

<p><em>Big ideas:</em></p>

<ul>
  <li>There are techniques you can apply to help produce efficient, straightforward proofs</li>
  <li>Wow proofs really are a lot like programs, aren‚Äôt they? Wait, which are we writing again?</li>
  <li>This really reminds me a lot of static analysis</li>
</ul>

<p>We start out looking at <code class="language-plaintext highlighter-rouge">memb?</code>, a function which looks for <code class="language-plaintext highlighter-rouge">'?</code> in a list, and <code class="language-plaintext highlighter-rouge">remb</code>, which removes the first instance of <code class="language-plaintext highlighter-rouge">'?</code> from a list. Are they total? Let‚Äôs look at <code class="language-plaintext highlighter-rouge">memb?</code> with a measure:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">defun</span> <span class="nv">memb?</span> <span class="p">(</span><span class="nf">xs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">xs</span><span class="p">)</span>
    <span class="ss">'nil</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">xs</span><span class="p">)</span> <span class="ss">'?</span><span class="p">)</span>
      <span class="ss">'t</span>
      <span class="p">(</span><span class="nf">memb?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">cs</span><span class="p">)))))</span>

<span class="nv">measure:</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">xs</span><span class="p">)</span></code></pre></figure>

<p>You can determine if <code class="language-plaintext highlighter-rouge">memb?</code> is total by proving its totality claim:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">natp</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">xs</span><span class="p">))</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">xs</span><span class="p">)</span>
    <span class="ss">'t</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">xs</span><span class="p">)</span> <span class="ss">'?</span><span class="p">)</span>
      <span class="ss">'t</span>
      <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nf">size</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">xs</span><span class="p">))</span> <span class="p">(</span><span class="nf">size</span> <span class="nv">xs</span><span class="p">))))</span>
  <span class="ss">'nil</span><span class="p">)</span></code></pre></figure>

<p>It is total, and so is <code class="language-plaintext highlighter-rouge">remb</code>, so we should be able to build theorems out of these functions. Which is exactly what we do next, with <code class="language-plaintext highlighter-rouge">memb?/remb0</code>, which states that <code class="language-plaintext highlighter-rouge">remb</code> removes <code class="language-plaintext highlighter-rouge">'?</code> from a 0-element list. Here‚Äôs the <code class="language-plaintext highlighter-rouge">dethm</code>:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">dethm</span> <span class="nv">memb?/remb0</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">memb?</span> <span class="p">(</span><span class="nf">remb</span> <span class="o">'</span><span class="p">()))</span> <span class="ss">'nil</span><span class="p">))</span></code></pre></figure>

<p>We can try to prove this using the axioms we‚Äôve learned so far. The bit to focus on is:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">memb?</span>
          <span class="p">(</span><span class="nf">remb</span> <span class="o">'</span><span class="p">()))</span>
        <span class="ss">'nil</span><span class="p">)</span></code></pre></figure>

<p>The first thing we should do is use the definition of <code class="language-plaintext highlighter-rouge">remb</code>, which we know to be total. We‚Äôll replace the <code class="language-plaintext highlighter-rouge">xs</code> in the definition of <code class="language-plaintext highlighter-rouge">remb</code> with <code class="language-plaintext highlighter-rouge">'()</code>.</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">memb?</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="o">'</span><span class="p">())</span>
              <span class="o">'</span><span class="p">()</span>
              <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">car</span> <span class="o">'</span><span class="p">())</span> <span class="ss">'?</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">remb</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">'</span><span class="p">()))</span>
                <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="o">'</span><span class="p">())</span>
                  <span class="p">(</span><span class="nf">remb</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">'</span><span class="p">()))))))</span>
          <span class="ss">'nil</span><span class="p">)</span></code></pre></figure>

<p>What can be simplified from this? Quite a bit, it turns out. This expression becomes:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">memb?</span>
          <span class="o">'</span><span class="p">())</span>
        <span class="ss">'nil</span><span class="p">)</span></code></pre></figure>

<p>By <code class="language-plaintext highlighter-rouge">atom</code> and <code class="language-plaintext highlighter-rouge">if-true</code>, because <code class="language-plaintext highlighter-rouge">'()</code> is an atom. Now, let‚Äôs use <code class="language-plaintext highlighter-rouge">memb?</code>, again replacing <code class="language-plaintext highlighter-rouge">xs</code> with <code class="language-plaintext highlighter-rouge">'()</code>:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">atom</span> <span class="o">'</span><span class="p">())</span>
           <span class="ss">'nil</span>
           <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">car</span> <span class="o">'</span><span class="p">())</span> <span class="ss">'?</span><span class="p">)</span>
               <span class="ss">'t</span>
               <span class="p">(</span><span class="nf">memb?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">'</span><span class="p">())))</span>
           <span class="ss">'nil</span><span class="p">)</span></code></pre></figure>

<p>Again we see the expression <code class="language-plaintext highlighter-rouge">atom '()</code>, which we know is true. So the above becomes:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">equal</span> <span class="ss">'nil</span>
       <span class="ss">'nil</span><span class="p">)</span></code></pre></figure>

<p>And we know that <code class="language-plaintext highlighter-rouge">memb?/remb0</code> is indeed a theoreom, by <code class="language-plaintext highlighter-rouge">atom</code>, <code class="language-plaintext highlighter-rouge">if-true</code>, and <code class="language-plaintext highlighter-rouge">equal-same</code>. Here‚Äôs how the above explanation looks when it‚Äôs written in J-Bob:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="nf">defun</span> <span class="nv">dethm</span><span class="o">.</span><span class="nv">memb?/remb0</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">J-Bob/define</span> <span class="p">(</span><span class="nf">defun</span><span class="o">.</span><span class="nv">remb</span><span class="p">)</span>
    <span class="o">'</span><span class="p">(((</span><span class="nf">dethm</span> <span class="nv">memb?/remb0</span> <span class="p">()</span>
         <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nf">memb?</span> <span class="p">(</span><span class="nf">remb</span> <span class="o">'</span><span class="p">()))</span> <span class="ss">'nil</span><span class="p">))</span>
       <span class="nv">nil</span>
       <span class="p">((</span><span class="nf">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">remb</span> <span class="o">'</span><span class="p">()))</span>
       <span class="p">((</span><span class="nf">1</span> <span class="mi">1</span> <span class="nv">Q</span><span class="p">)</span> <span class="p">(</span><span class="nf">atom</span> <span class="o">'</span><span class="p">()))</span>
       <span class="p">((</span><span class="nf">1</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">if-true</span> <span class="o">'</span><span class="p">()</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">car</span> <span class="o">'</span><span class="p">())</span> <span class="ss">'?</span><span class="p">)</span> <span class="p">(</span><span class="nf">remb</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">'</span><span class="p">()))</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="o">'</span><span class="p">())</span> <span class="p">(</span><span class="nf">remb</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">'</span><span class="p">()))))))</span>
       <span class="p">((</span><span class="nf">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">memb?</span> <span class="o">'</span><span class="p">()))</span>
       <span class="p">((</span><span class="nf">1</span> <span class="nv">Q</span><span class="p">)</span> <span class="p">(</span><span class="nf">atom</span> <span class="o">'</span><span class="p">()))</span>
       <span class="p">((</span><span class="nf">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">if-true</span> <span class="ss">'nil</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="p">(</span><span class="nb">car</span> <span class="o">'</span><span class="p">())</span> <span class="ss">'?</span><span class="p">)</span> <span class="ss">'t</span> <span class="p">(</span><span class="nf">memb?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">'</span><span class="p">())))))</span>
       <span class="p">(()</span> <span class="p">(</span><span class="nf">equal-same</span> <span class="ss">'nil</span><span class="p">))))))</span></code></pre></figure>

<p>This is an executable program that will prove that this function is a theorem - cool!</p>

<p>The authors take us through a similar procedure to prove successive functions on top of <code class="language-plaintext highlighter-rouge">memb?/remb0</code> - <code class="language-plaintext highlighter-rouge">memb?/remb1</code>, <code class="language-plaintext highlighter-rouge">memb?/remb2</code>, etc. They lead up to the question that would occur to anyone paying attention to the book up until this point - couldn‚Äôt this be generalized? What techniques can we use to perform recursion like proofs? The answer is induction, and it is the big idea for the second half of the book.</p>

<p>While we‚Äôre shown how proving the successive functions to <code class="language-plaintext highlighter-rouge">memb?/remb0</code> isn‚Äôt exactly as straightforward as you‚Äôd think, we‚Äôre given some nice insights into how to effectively write proofs with our system:</p>

<p><strong>Rewrite from the Inside Out</strong></p>

<p>Start with the statements ‚Äúinside‚Äù the code, the things that are nested and squirreled away. Simplify them and then the entire proof will become simpler</p>

<p><strong>If Lifting</strong></p>

<p>We‚Äôre shown this technique which really resonated with me as a programmer, because again it reminds me of the kinds of insights you form about programs in a certainly language after writing with it for a decent amount of time. Most experienced programmers will be able to recognize certain simplifications that can be made to code that will preserve its meaning but make its intent clearer, improve performance, etc. Similarly, we‚Äôre given techniques that simplify proofs without changing their meaning. Pretty sweet.</p>

<p><strong>Pull Ifs Outward</strong></p>

<p>This is a piece of wisdom based on the mechanic provided above - that is, use if lifting! It can simplify what you‚Äôre trying to prove radically.</p>

<p><strong>Keep Theorems in Mind</strong></p>

<p>Another piece of advice from the authors which I can‚Äôt help but draw a parallel to software engineering about. Keeping theorems in mind is about recognizing the patterns in your code that can be simplified using axioms, but also about recognizing when you‚Äôre <em>close</em> to a pattern. When you‚Äôre close to a pattern, make some minor changes around your statements, and you might reveal that pattern. This reminds me a lot of the ways that software developers apply patterns, and look for ‚Äúsmells‚Äù or clues that they might be doing something wrong, or every once in a while, something right.</p>
:ET